import os

# c代码模板
c_mod = '//This file is automatically generated by h2interface.py\n' \
        '[includes]\n\n' \
        '[funcs]\n' \
 \
# 头文件模板
include_mod = '#include "[head_name]"'

# 函数模板
fun_mod = '[return_type] py_[fun_name][dis] ([f_args]){\n' \
          '\t[return_type] b = [fun_name]([a_args]);\n' \
          '\treturn b;\n' \
          '}\n'

# c语言中的数据类型关键字
type_list = ['int', 'float', 'double', 'char', 'unsigned', 'long', 'short', 'byte']

# # 指针修正：
# def replace_pointer(code):
#     pointer_list = {
#         'ctypes.c_int*(x\d)': 'int_p'
#     }

# python模板：
py_mod = 'import ctypes\n' \
         'class Interface:\n' \
         '\tdef __init__(self, so_path:str = \'./put.so\'):\n' \
         '\t\tself.so = ctypes.cdll.LoadLibrary(so_path)\n' \
         '[inits]\n\n' \
         '[funcs]\n'

# python init 模板：
init_mod = '\t\tself.so.py_[fun_name].restype = ctypes.c_[return_type]'

# python fun 模板：
py_fun_mod = '\tdef [fun_name](self, [f_args]):\n' \
             '\t\treturn self.so.py_[fun_name]([a_args])\n'


# 对头文件中的语句进行过滤
def preprocess(lines):
    fun_lines = []
    for line in lines:
        if line is None or line.replace(' ', '')[0] in ['/', '#', '*', '\n']:  # 注释，定义, 空行等数据直接过滤掉
            pass
        elif line.split(' ')[0] in type_list or line.split(' ')[0] in ['extern']:
            fun_lines.append(line.replace('\t', '').replace('\n', ''))

    return fun_lines


# 从头文件语句中得到函数
def explain_funs(lines):
    fun_infos = []
    for line in lines:
        line = line.replace(',', ' , ').replace('*', ' * ').replace('(', ' ').replace(')', ' ')
        elemts = line.split(' ')
        fun_info = {
            'name': None,
            'return_type': [],
            'args': [],
            'dis': ''
        }
        for e in elemts:
            if e in ['extern', '']:
                pass
            elif e in type_list or e == ',' or e == '*':
                if fun_info['name'] is None:
                    fun_info['return_type'].append(e)
                else:  # 当返回值类型已经获得
                    fun_info['args'].append(e)
            elif fun_info['name'] is None and len(fun_info['return_type']) >= 0:  # 当 e 不是类型名, 且返回值类型已经获得
                fun_info['name'] = e

        # 后处理
        if len(fun_info['args']) == 0:
            continue

        fun_info['args'] = ''.join(fun_info['args']).split(',')
        if '*' in fun_info['args'] or '' in fun_info:
            continue

        fun_info['return_type'] = ' '.join(fun_info['return_type'])
        fun_infos.append(fun_info)

    # 函数重名处理：
    fun_dict = {}
    for fun_info in fun_infos:
        if fun_info['name']+fun_info['dis'] not in fun_dict.keys():
            fun_dict[fun_info['name']+fun_info['dis']] = fun_info
        else:
            fun_info['dis'] = '_'
            for t in fun_info['args']:
                fun_info['dis'] += t[0]
            fun_dict[fun_info['name']+fun_info['dis']] = fun_info
    fun_infos = [fun_dict[i] for i in fun_dict]

    return fun_infos


# 将explain_funs得到的函数翻译成c代码
def funs2code(funs):
    code_funs = []
    for fun in funs:
        f_args = ','.join([p + ' x{}'.format(i) for i, p in enumerate(fun['args'])])
        a_args = ','.join(['x{}'.format(i) for i, p in enumerate(fun['args'])])
        code_fun = fun_mod.replace('[return_type]', fun['return_type']).replace('[fun_name]', fun['name']). \
            replace('[f_args]', f_args).replace('[a_args]', a_args).replace('[dis]', fun['dis'])
        code_funs.append(code_fun)

    return code_funs


# 将头文件翻译成c代码 preprocess、explain_funs、funs2code
def fun_extract_in_h(head_path: str):
    code_funs = []
    with open(head_path, 'r') as hf:
        line = hf.readline()
        lines = [line]
        while line:
            lines.append(line)
            line = hf.readline()
        lines = preprocess(lines)
        lines = explain_funs(lines)
        # lines = funs2code(lines)
        # funcs = '\n'.join(lines)
        return lines


# 将explain_funs翻译成python代码：
def funs2pycode(funs):
    inits = []
    code_funs = []
    for fun in funs:
        # 生成形参
        f_args = ','.join(['x{}'.format(i) for i, p in enumerate(fun['args'])])
        # 生成实参
        a_args = []
        for i, p in enumerate(fun['args']):
            if '*' in p:
                a_args.append('ctypes.byref(ctypes.c_{}(x{}))'.format(p, i).replace('*', ''))
            else:
                a_args.append('ctypes.c_{}(x{})'.format(p, i))
        a_args = ', '.join(a_args)
        # 生成初始化语句
        if not '*' in fun['return_type']:
            init = init_mod.replace('[fun_name]', fun['name']).replace('[return_type]', fun['return_type'])
        else:
            continue

        code_fun = py_fun_mod.replace('[fun_name]', fun['name']).replace('[f_args]', f_args).replace('[a_args]', a_args)
        code_funs.append(code_fun)
        inits.append(init)

    return inits, code_funs


# 生成interface.c 和 interface.py 文件
def generate_interface_c_and_py(root: str = './'):
    includes = []
    code_funs = []

    inits = []
    py_code_funs = []

    with open('./output/log.txt', 'w') as logf:
        logf.write('interface.c and interface.py being generated...\n')
        f_list = os.listdir(root)
        for f in f_list:
            if f.split('.')[-1] in ['h', 'hpp']:
                includes.append(include_mod.replace('[head_name]', f))
                dict_funs = fun_extract_in_h(os.path.join(root, f))
                logf.write('finding {} functions in {}...\n'.format(len(dict_funs), f))
                code_funs.append(
                    '//The nest functions are extract by {}\n'.format(f) + '\n'.join(funs2code(dict_funs))
                )
                t_inits, t_pyfuns = funs2pycode(dict_funs)
                inits.append('\n'.join(t_inits))
                py_code_funs.append('\n'.join(t_pyfuns))

        code = c_mod.replace('[includes]', '\n'.join(includes)). \
            replace('[funcs]', '\n'.join(code_funs))
        logf.write('interface.c is generate:\n')
        logf.write(code + '\n')
        with open('./source/interface.c', 'w') as f:
            f.write(code)

        py_code = py_mod.replace('[inits]', '\n'.join(inits)). \
            replace('[funcs]', '\n'.join(py_code_funs))
        logf.write('interface.py is generate:\n')
        logf.write(py_code + '\n')
        with open('./output/interface.py', 'w') as f:
            f.write(py_code)
        logf.write('finished!\n')


if __name__ == '__main__':
    generate_interface_c_and_py('./source')